name: Note Workflow (Gemini版)

on:
  workflow_dispatch:
    inputs:
      theme:
        description: '記事テーマ'
        required: true
        type: string
      target:
        description: '想定読者（ペルソナ）'
        required: true
        type: string
      message:
        description: '読者に伝えたい核メッセージ'
        required: true
        type: string
      cta:
        description: '読後のアクション（CTA）'
        required: true
        type: string
      tags:
        description: 'カンマ区切りタグ（任意）'
        required: false
        default: ''
        type: string
      is_public:
        description: '公開(true)/下書き(false)'
        required: true
        default: 'false'
        type: choice
        options: ['true','false']
      dry_run:
        description: '投稿をスキップ（生成のみ）'
        required: true
        default: 'false'
        type: choice
        options: ['true','false']

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

jobs:
  generate:
    name: Generate article with Gemini API
    runs-on: ubuntu-latest
    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      THEME:  ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
      MESSAGE: ${{ github.event.inputs.message }}
      CTA:    ${{ github.event.inputs.cta }}
      TAGS:   ${{ github.event.inputs.tags }}
    outputs:
      title:      ${{ steps.collect.outputs.title }}
      article_b64: ${{ steps.collect.outputs.article_b64 }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install deps
        run: |
          npm init -y
          npm i node-fetch

      - name: Generate article with Gemini
        run: |
          cat > gemini-note.mjs <<'EOF'
          import fetch from "node-fetch";
          import fs from "fs";

          const API_KEY = process.env.GEMINI_API_KEY;
          const THEME  = process.env.THEME ?? "";
          const TARGET = process.env.TARGET ?? "";
          const MESSAGE = process.env.MESSAGE ?? "";
          const CTA    = process.env.CTA ?? "";
          const TAGS   = process.env.TAGS ?? "";

          const prompt = `
          あなたはnoteで人気記事を執筆するプロのライターです。
          以下の条件に基づいて、Markdown形式で記事を作成してください。

          # テーマ
          ${THEME}

          # 想定読者
          ${TARGET}

          # 伝えたいメッセージ
          ${MESSAGE}

          # 読後のアクション
          ${CTA}

          # タグ
          ${TAGS}

          ## 出力条件
          - Markdown形式で出力
          - タイトルを一行目に「# 」で記載
          - 小見出しや箇条書きを活用
          - note向けの自然な文体
          - 2000～4000文字程度
          `;

          const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${API_KEY}`;
          const res = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [{ role: "user", parts: [{ text: prompt }]}]
            })
          });

          const data = await res.json();
          const text = data?.candidates?.[0]?.content?.parts?.[0]?.text ?? "出力なし";
          const titleMatch = text.match(/^#\s*(.+)/);
          const title = titleMatch ? titleMatch[1] : "タイトル（自動生成）";

          fs.writeFileSync(".note-article.md", text, "utf8");
          fs.writeFileSync(".note-title.txt", title, "utf8");
          console.log("=== 生成タイトル ===", title);
          EOF

          node gemini-note.mjs

      - name: Collect outputs
        id: collect
        run: |
          title=$(cat .note-title.txt)
          b64=$(base64 -w 0 .note-article.md 2>/dev/null || base64 .note-article.md)
          {
            echo "title<<EOF"
            echo "$title"
            echo "EOF"
            echo "article_b64<<EOF"
            echo "$b64"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  post:
    name: Post to note.com (Playwright)
    needs: generate
    if: ${{ github.event.inputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    env:
      IS_PUBLIC:  ${{ github.event.inputs.is_public }}
      STATE_JSON: ${{ secrets.NOTE_STORAGE_STATE_JSON }}
      START_URL:  https://editor.note.com/new

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright + marked
        run: |
          npm init -y
          npm i playwright marked
          npx playwright install --with-deps chromium | cat

      - name: Prepare storageState
        id: state
        run: |
          test -n "$STATE_JSON" || (echo "ERROR: NOTE_STORAGE_STATE_JSON secret is not set" && exit 1)
          mkdir -p "$RUNNER_TEMP"
          printf '%s' "$STATE_JSON" > "$RUNNER_TEMP/note-state.json"
          echo "STATE_PATH=$RUNNER_TEMP/note-state.json" >> "$GITHUB_OUTPUT"

      - name: Restore article
        env:
          ARTICLE_B64: ${{ needs.generate.outputs.article_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$ARTICLE_B64" | base64 -d > .note-artifacts/article.md || echo "$ARTICLE_B64" | base64 --decode > .note-artifacts/article.md

      - name: Publish via Playwright (robust)
        env:
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
        run: |
          set -euo pipefail
          cat > post.mjs <<'EOF'
          import { chromium } from "playwright";
          import fs from "fs";

          const STATE_PATH = process.env.STATE_PATH;
          const IS_PUBLIC  = String(process.env.IS_PUBLIC || "false") === "true";
          const START_URL  = process.env.START_URL || "https://editor.note.com/new";
          const md         = fs.readFileSync(".note-artifacts/article.md", "utf8");
          const titleMatch = md.match(/^#\s*(.+)/);
          const title      = titleMatch ? titleMatch[1] : "タイトル（自動生成）";

          // --- Cookie補完 ---
          let storage = JSON.parse(fs.readFileSync(STATE_PATH, "utf8"));
          const domains = new Set([".note.com", "note.com", ".editor.note.com", "editor.note.com"]);
          if (Array.isArray(storage.cookies)) {
            const extra = [];
            for (const c of storage.cookies) {
              if (!String(c.domain).includes("note.com")) continue;
              for (const d of domains) {
                if (c.domain === d) continue;
                extra.push({ ...c, domain: d });
              }
            }
            storage.cookies.push(...extra);
            fs.writeFileSync(STATE_PATH, JSON.stringify(storage, null, 2));
          }

          // --- ブラウザ起動 ---
          const browser = await chromium.launch({
            headless: true,
            args: ["--disable-dev-shm-usage", "--no-sandbox", "--disable-gpu"]
          });

          const context = await browser.newContext({
            storageState: STATE_PATH,
            locale: "ja-JP",
            viewport: { width: 1280, height: 900 }
          });

          const page = await context.newPage();

          // --- ログイン確認 ---
          await page.goto(START_URL, { waitUntil: "domcontentloaded", timeout: 90000 });
          if (page.url().includes("/login")) {
            console.log("⚠️ ログイン再適用");
            await context.clearCookies();
            await context.addCookies(storage.cookies);
            await page.goto(START_URL, { waitUntil: "domcontentloaded", timeout: 90000 });
          }

          // --- タイトル入力 ---
          const titleSelectors = [
            'div[contenteditable="true"][data-placeholder*="タイトル"]',
            'div[role="textbox"][contenteditable="true"]',
            'textarea[placeholder*="タイトル"]'
          ];
          let titleBox = null;
          for (const sel of titleSelectors) {
            const box = await page.$(sel);
            if (box) {
              titleBox = box;
              break;
            }
          }

          if (!titleBox) {
            console.error("❌ タイトル欄が見つかりません");
            await page.screenshot({ path: ".note-artifacts/error_title.png", fullPage: true });
            await browser.close();
            process.exit(1);
          }

          await titleBox.click({ clickCount: 3 });
          await titleBox.press("Backspace");
          await titleBox.type(title);
          console.log("✅ タイトル入力完了:", title);

          // --- 本文入力 ---
          const bodySel = 'div[contenteditable="true"]:not([data-placeholder*="タイトル"])';
          const bodyBox = await page.$(bodySel);
          if (!bodyBox) {
            console.error("❌ 本文欄が見つかりません");
            await page.screenshot({ path: ".note-artifacts/error_body.png", fullPage: true });
            await browser.close();
            process.exit(1);
          }

          await bodyBox.click();
          await page.keyboard.type(md.slice(0, 5000));
          console.log("✅ 本文入力完了");

          // --- 下書き or 公開 ---
          if (!IS_PUBLIC) {
            try {
              const saveBtn = page.locator('button:has-text("下書き保存")').first();
              if (await saveBtn.isVisible()) {
                await saveBtn.click();
                console.log("✅ 下書き保存完了");
              } else {
                console.log("⚠️ 下書きボタン未検出（自動保存モード？）");
              }
            } catch {
              console.log("⚠️ 自動保存検出");
            }
            await browser.close();
            process.exit(0);
          }

          // --- 公開投稿 ---
          try {
            const proceed = page.locator('button:has-text("公開に進む")').first();
            await proceed.waitFor({ state: "visible", timeout: 60000 });
            await proceed.click();

            const publishBtn = page.locator('button:has-text("投稿する")').first();
            await publishBtn.waitFor({ state: "visible", timeout: 60000 });
            await publishBtn.click();
            console.log("✅ 公開投稿完了");
          } catch (e) {
            console.error("❌ 公開処理エラー:", e.message);
            await page.screenshot({ path: ".note-artifacts/error_publish.png", fullPage: true });
          }

          await browser.close();
          EOF

          node post.mjs

      - name: Upload debug artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: note-debug-artifacts
          path: |
            .note-artifacts/**
            .note-article.md
            .note-title.txt
          if-no-files-found: ignore
